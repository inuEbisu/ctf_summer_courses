# Rev Lab 3: 符号执行

本节 Lab 包含如下三个部分

- [程序分析相关](#part-1-10) (10%)
- [符号执行示例相关](#part-2-30) (30%)
- [符号执行实战相关](#part-3-60) (60%)

本次 lab 的 ddl 在发布两周半以后即 7 月 30 日晚 23:59，请注意安排时间。在做题过程中遇到任何问题，都请及时联系，对于共性问题会考虑继续放出 hint。私聊提问时请务必说明你目前的进度及已经尝试的方法等。

### Challenge

我们本节课在阐述符号执行前，先从程序分析基础的角度切入。接着，以 angr 为例介绍了符号执行在逆向解题中的使用。此后，分析了符号执行的不足之处（以及可能的"补救"方法），最后，介绍了其他能减少逆向中人工工作的思路和方向。

这一部分主要考验你对课堂内容的掌握，以及对符号执行 (angr) 的熟练使用。

## Part 1 (10%)

我们在课上演示了通过编译器 `clang` 功能分析给定 C 程序的控制流图 (CFG) 与函数调用图 (callgraph)。

请参照课上的演示，通过 C/C++ 编写一个递归程序（如非波拉契数列），并运用 `clang` 针对该程序进行分析。要求要求在实验报告中提供

- 分析过程中使用的命令和分析的结果图 (5%)
- 描述分析结果，如记录存在哪些基本块？存在哪些调用函数 (5%)
  - 特别的，在之前的课程中，我们知道一个 ELF 程序的运行期间还包括了很多其他必要的函数，如 `__libc_start_main`。请分析函数调用图中是否包含了该函数？如果不包含，为什么？

## Part 2 (30%)

我们在课上通过 angr 完成了对多个目标的分析，如 `babyrev` 和 `childrev` 等等。

请参照课上的演示，前往 angr 的官方示例仓库**任选 2 道赛题**进行学习。

https://github.com/angr/angr-examples/tree/master

要求在实验报告中包含:

- 简述示例（被分析的）目标程序的逻辑
  - 对于复杂的程序可以从 angr 脚本中反推
- 逐行分析和解释示例中 angr 的使用
  - 多数示例中已经包含了大量注释，这种情况下请*至少*做到翻译和理解

> 两道题的复现分析各占 15% 分数

## Part 3 (60%)

### crackme (30%)

课堂上以 `crackme` 程序为例，展现了 angr 为代表的符号执行工具对于**简单**但是**冗长**的情况。

请参照课上的演示，完成对于 `crackme` 程序的复现，通过 angr 符号执行的方式得到 flag，要求要求在实验报告中提供

- 通过 `entry_state` 完成执行的脚本和分析 (15%)
- 通过 `call_state` 完成执行的脚本和分析 (15%)


### crackme revenge (30%)

课堂上提到 `crackme` 的复杂程度只是百指令级，而 `crackme.revenge` 带着千级别的指令复杂度来了。

题目已经发布在网站上，https://ctf.zjusec.com/games/5/challenges

请参考课上的演示通过符号执行求解题目 flag，要求要求在实验报告中提供

- 符号执行的代码 (10%)
- 题目求解的思路 (10%)
- 最终获得 flag 提交成功得到截图 (10%)

**HINT: 指定初始化状态的入口地址与执行目标的终点地址**